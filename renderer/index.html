<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

<div id="app"></div>
<button id="btn">test</button>

<script src="reactive/index.js"></script>
<script src="index.js"></script>
<script>
  const { effect, ref } = VueReactivity

  const content = 'hello world!'
  const count = ref(1)

  const container = document.querySelector('#app')

  function shouldSetAsProps(el, key, value) {
    if (key === 'form' && el.tagName === 'INPUT')
      return false
    return key in el
  }

  const renderer = createRenderer({
    // 创建元素
    createElement(tag) {
      return document.createElement(tag)
    },
    // 设置元素的文本节点
    setElementText(el, text) {
      el.textContent = text
    },
    // 用于给指定parent下添加指定元素
    insert(el, parent, anchor = null) {
      parent.insertBefore(el, anchor)
    },
    // prevValue 之前的属性值，nextValue现在的
    patchProps(el, key, prevValue, nextValue) {
      if (/^on/.test(key)) {
        // 添加事件绑定相关逻辑
        // vei => vueEventInvoker
        const invokers = el._vei || (el._vei = {})  // {}
        // invoker只是一个临时变量 el._vei是将vueEventInvoker缓存
        let invoker = invokers[key] // 取出对象中的属性
        // 监听事件名称
        const name = key.slice(2).toLowerCase()
        if (nextValue) {
          if (!invoker) {
            // 如果没有invoker 则构建
            invoker = el._vei[key] = (e) => {
              // e.timeStamp 是事件的发生时间
              if (e.timeStamp < invoker.attached) return
              if (Array.isArray(invoker.value)) {
                invoker.value.forEach(fn => fn(e))
              } else {
                invoker.value(e)
              }
            }
            // 此处的nextValue 就是 vnode.props['onClick'] = Array<Function> || Function
            invoker.value = nextValue
            // 事件处理函数对象上添加 attached属性
            invoker.attached = performance.now()
            el.addEventListener(name, invoker)
          } else {
            // 引用类型修改数据
            invoker.value = nextValue
          }
        } else {
          // 绑定事件不存在（解绑），且之前绑定的invoker存在
          el.removeEventListener(name, invoker)
        }
      } else if(key === 'class') {
        el.className = nextValue || ''
      } else if (shouldSetAsProps(el, key, nextValue)) {
        const type = typeof el[key]
        if (type === 'boolean' && nextValue === '') {
          el[key] = true
        } else {
          el[key] = nextValue
        }
      } else {
        el.setAttribute(key, nextValue)
      }
    }
  })

  const vnode = {
    type: 'div',
    props: {
      id: 'foo',
      onClick: [
        () => {
          alert('clicked 1')
        },
        () => {
          alert('clicked 2')
        }
      ],
      onContextmenu: () => {
        alert('contextmenu')
      }
    },
    children: [
      {
        type: 'p',
        children: 'hello'
      }
    ]
  }

  effect(() => {
    // 相当于副作用函数
    renderer.render(vnode, container)
  })

  count.value++
</script>

</body>
</html>